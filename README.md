**About This Software**
The purpose of this software is to plan a trajectory for the end effector of a youBot robot so that it is able to pick up a block at a specified location and place it at a desired location through the use of odometry as the chassis is moving and feedback control. The software to run this simulation is denoted as "main.py", which consists of three functions that were initially split into seperate milestones, which are also included as "milestonex.py" if you wold like to test out each piece seperately for errors/adjustments. Overview of "main.py":
1. The number of configurations is defined as N and is passed onto the trajectory generator functions in order to generate a reference trajectory for the gripper of the robot, which defines multiple transformation matrices comprising of configurations of frames relative to each other. The code contains comments describing each frame. Frames are as follows: s (space) frame, e (end effector) frame, c (cube) frame. The i,d, and g subscripts for these frames represents initial, desired, and grasping configuration. Initial frames are used to change reference frames and compute the relevant transformations to achieve the following steps:
    a. trajectory to move the gripper from its initial configuration to a "standoff" configuration a few cm above the block.
    b. trajectory to move the gripper down to the grasp position.
    c. Closing of the gripper.
    d. trajectory to move the gripper back up to the "standoff" configuration.
    e. trajectory to move the gripper to a "standoff" configuration above the   final configuration.
    f. A trajectory to move the gripper to the final configuration of the object.
    g. Opening of the gripper.
    h. A trajectory to move the gripper back to the "standoff" configuration. 
Trajectories are saved in a CSV file.
2. Initial configurations for the chassis, wheels, and joints are defined and a loop is defined to iterate N-1 times over the generated trajectories. In this loop, joint angles are extracted from the configuration variable, the initial transformation matrix of the chassis (b frame) relative to the s frame is defined, and the reference transformation of the end effector frame relative to the s frame are defined for the current and next timestep, denoted as Xd, and Xdnext.
3. The inputs defined above are passed into the feedback control function, which generates the wheel and joint angle speeds. This function computes the current actual end effector reference configuration, the end effector jacobian, and defined PI gain matrices Kp and Ki in order to compute command end effector twist using the kinematic task-space feedforward plus feedback control law. The resulting twist and jacobian is used to extract the desired wheel and joint speeds.
4. the wheel and joint speeds are seperately extracted from the return vale of the function and constants are defined, which are passed in the NextStates function, which is the main function that simulates the youBot. This function generates a new configuration of the youBot using the compuetd control speeds, previous configuration, and pre-initialized constants. This function first compares each of the computed wheel and joint speeds to a max speed and will adjust if out of bounds. The new joint and wheel angles are computed and the configuration of the chassis in terms of phi,x,and y is computed through odometry methods (see code for more detail).
5. Gripper state is added to the end of the newly generated configuration and the loop is repeated N-1 times. Once loop completes, configurations are saved in a CSV file and can be loaded into V-REP for simulation. 

**Results**
The results show the youBot able to move to pick the block up, carry it to its destination, and put it back down. One interesting thing noted is that every once in a while, the gripper loses grip of the block and the block will fall out. This can easily be fixed by allotting more time for the gripper to properly grip the block, and possibly adjust the the position of the end effector relative to the block frame for a better grip. Another thing noted was that when gain matrices are increased, the final placement of the block is more accurrate. When gains of 1s were used, the block was not placed at the exact final configuration and would often times roll over to a more innaccurrate position. This was correctly fixed by multiplying the gains by a scalar of 2. Results are shown in the results directory. 
